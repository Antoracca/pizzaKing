rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ========================================
    // HELPER FUNCTIONS - AUTHENTICATION
    // ========================================

    function isSignedIn() {
      return request.auth != null;
    }

    function uid() {
      return request.auth.uid;
    }

    // ========================================
    // HELPER FUNCTIONS - ROLE MANAGEMENT
    // ðŸ” Utilise CUSTOM CLAIMS (rapide, sÃ©curisÃ©, pas de get() Firestore)
    // ========================================

    function userRole() {
      // Lire le rÃ´le depuis le JWT token (custom claim)
      return request.auth.token.role;
    }

    function isCustomer() {
      // Un utilisateur est considÃ©rÃ© comme customer si :
      // 1. Il a explicitement le role 'customer' dans le JWT
      // 2. OU il est authentifiÃ© mais n'a pas encore de role (nouveaux users)
      // Ceci permet aux nouveaux utilisateurs de fonctionner avant que onUserCreate ne s'exÃ©cute
      return isSignedIn() && (userRole() == 'customer' || userRole() == null);
    }

    function isAdmin() {
      return isSignedIn() && userRole() == 'admin';
    }

    function isSuperadmin() {
      return isSignedIn() && userRole() == 'superadmin';
    }

    function isAdminRole() {
      return isAdmin() || isSuperadmin();
    }

    function isSupportAgent() {
      return isSignedIn() && userRole() == 'support_agent';
    }

    function isSupportManager() {
      return isSignedIn() && userRole() == 'support_manager';
    }

    function isSupportBackoffice() {
      return isSignedIn() && userRole() == 'support_backoffice';
    }

    function isSupportStaff() {
      return isAdminRole() || isSupportAgent() || isSupportManager() || isSupportBackoffice();
    }

    function isSystem() {
      return isSignedIn() && request.auth.token.role == 'system';
    }

    // ========================================
    // HELPER FUNCTIONS - VALIDATION
    // ========================================

    function isValidTicketStatus(status) {
      return status in ['open', 'in_progress', 'pending', 'resolved'];
    }

    function isValidMessageSender(sender) {
      return sender in ['user', 'agent', 'system'];
    }

    function isValidMessageStatus(status) {
      return status in ['pending', 'sent', 'delivered', 'read'];
    }

    // ========================================
    // HELPER FUNCTIONS - TICKET OWNERSHIP
    // ========================================

    function isTicketOwner(ticketData) {
      return isSignedIn() && ticketData.userId == uid();
    }

    function isAssignedAgent(ticketData) {
      return isSignedIn()
        && ticketData.assignedAgentId != null
        && ticketData.assignedAgentId == uid();
    }

    function canAccessTicket(ticketData) {
      return isSupportStaff() || isSystem() || isTicketOwner(ticketData);
    }

    // ========================================
    // COLLECTION: users
    // ========================================

    match /users/{userId} {
      // Lecture: TOUT LE MONDE peut lire (mÃªme non authentifiÃ©)
      // NÃ©cessaire pour:
      // 1. VÃ©rifier les doublons email/phone lors de l'inscription (AVANT auth)
      // 2. FonctionnalitÃ©s support (affichage nom client, etc.)
      allow get, list: if true;

      // CrÃ©ation: un utilisateur ne peut crÃ©er que son propre document
      // Validation minimale pour permettre l'inscription Google/Email sans blocage
      allow create: if isSignedIn()
        && uid() == userId
        && request.resource.data.id == userId
        && request.resource.data.role == 'customer';

      // Mise Ã  jour: un utilisateur peut modifier son profil
      // SAUF les champs critiques (role, id, email, createdAt, provider)
      // Permet la mise Ã  jour de emailVerified, phoneVerified en temps rÃ©el
      // Note: On vÃ©rifie seulement les champs qui sont prÃ©sents dans la requÃªte
      allow update: if isSignedIn()
        && uid() == userId
        // Si id est prÃ©sent, il ne doit pas changer
        && (!('id' in request.resource.data) || request.resource.data.id == resource.data.id)
        // Si createdAt est prÃ©sent, il ne doit pas changer
        && (!('createdAt' in request.resource.data) || request.resource.data.createdAt == resource.data.createdAt)
        // Si role est prÃ©sent, il ne doit pas changer
        && (!('role' in request.resource.data) || request.resource.data.role == resource.data.role)
        // Si provider est prÃ©sent, il ne doit pas changer
        && (!('provider' in request.resource.data) || request.resource.data.provider == resource.data.provider)
        // Si email est prÃ©sent, il ne doit pas changer
        && (!('email' in request.resource.data) || request.resource.data.email == resource.data.email);

      // Suppression: interdit
      allow delete: if false;
    }

    // ========================================
    // COLLECTION: supportTickets
    // ========================================

    match /supportTickets/{ticketId} {

      // Lecture: staff support OU propriÃ©taire du ticket
      allow get: if isSignedIn() && (
        isSupportStaff()
        || isSystem()
        || resource.data.userId == uid()
      );

      // Liste: staff support peut tout lister, clients peuvent lister leurs propres tickets
      allow list: if isSupportStaff() || isSystem()
        || (isSignedIn() && request.auth.uid != null && resource.data.userId == request.auth.uid);

      // CrÃ©ation: clients crÃ©ent leurs tickets, staff peut crÃ©er aussi
      allow create: if isSignedIn() && (
        // Cas 1: Client crÃ©e son propre ticket (customers OU admins pour testing)
        ((isCustomer() || isAdminRole())
          && request.resource.data.userId == uid()
          && request.resource.data.status in ['open', 'pending']
          && request.resource.data.channel == 'chat'
          && request.resource.data.createdAt is timestamp
          && request.resource.data.updatedAt is timestamp
          && request.resource.data.unreadCountForAgent is int
          && request.resource.data.unreadCountForUser is int
          && (!('assignedAgentId' in request.resource.data) || request.resource.data.assignedAgentId == null)
        )
        // Cas 2: Staff support crÃ©e un ticket
        || isSupportStaff()
        || isSystem()
      );

      // Mise Ã  jour: staff support OU propriÃ©taire du ticket (avec restrictions)
      allow update: if isSignedIn() && (
        // Cas 1: Staff support peut tout modifier
        isSupportStaff() || isSystem()

        // Cas 2: Client peut modifier son propre ticket (champs mÃ©tadonnÃ©es seulement)
        || (
          (isCustomer() || isAdminRole())
          && resource.data.userId == uid()
          && request.resource.data.userId == uid()
          // Le client peut seulement modifier ces champs spÃ©cifiques
          && resource.data.diff(request.resource.data).affectedKeys().hasOnly([
            'status', 'updatedAt', 'lastMessageAt', 'lastMessagePreview',
            'lastMessageSender', 'unreadCountForAgent', 'unreadCountForUser',
            'autoReplySent'
          ])
          // Le client ne peut pas changer l'assignation
          && (!resource.data.diff(request.resource.data).affectedKeys().hasAny(['assignedAgentId', 'assignedAgentName']))
          // Le client ne peut pas rÃ©soudre un ticket
          && (request.resource.data.status != 'resolved' || resource.data.status == 'resolved')
        )
      );

      // Suppression: interdit
      allow delete: if false;

      // ========================================
      // SUBCOLLECTION: messages
      // ========================================

      match /messages/{messageId} {

        // Lecture: tous les utilisateurs authentifiÃ©s peuvent lire les messages
        // (la sÃ©curitÃ© est gÃ©rÃ©e au niveau du ticket parent)
        allow get, list: if isSignedIn();

        // CrÃ©ation: user peut crÃ©er dans son ticket, staff peut crÃ©er partout
        allow create: if isSignedIn() && (
          // Cas 1: Client envoie un message user (customers OU admins pour testing)
          ((isCustomer() || isAdminRole())
            && request.resource.data.sender == 'user'
            && request.resource.data.senderId == uid()
            && request.resource.data.ticketId == ticketId
            && request.resource.data.text is string
            && request.resource.data.text.size() > 0
            && request.resource.data.text.size() <= 5000
            && request.resource.data.createdAt is timestamp
          )

          // Cas 2: Client crÃ©e auto-reply system (validation stricte)
          || ((isCustomer() || isAdminRole())
            && request.resource.data.sender == 'system'
            && request.resource.data.isAutoReply == true
            && request.resource.data.ticketId == ticketId
            && request.resource.data.text is string
            && request.resource.data.createdAt is timestamp
          )

          // Cas 3: Staff support envoie un message
          || (isSupportStaff()
            && request.resource.data.sender in ['agent', 'system']
            && request.resource.data.ticketId == ticketId
            && request.resource.data.text is string
            && request.resource.data.text.size() > 0
            && request.resource.data.text.size() <= 5000
            && request.resource.data.createdAt is timestamp
          )

          // Cas 4: SystÃ¨me
          || isSystem()
        );

        // Mise Ã  jour: pour marquer comme lu (tous les users authentifiÃ©s)
        allow update: if isSignedIn();

        // Suppression: interdit
        allow delete: if false;
      }

      // ========================================
      // SUBCOLLECTION: events
      // ========================================

      match /events/{eventId} {

        // Lecture: tous les utilisateurs authentifiÃ©s peuvent lire les events
        allow get, list: if isSignedIn();

        // CrÃ©ation: staff support seulement
        allow create: if isSupportStaff() || isSystem();

        // Mise Ã  jour et suppression: interdit
        allow update, delete: if false;
      }

      // ========================================
      // SUBCOLLECTION: presence
      // ========================================

      match /presence/{presenceId} {

        // Lecture: tous les utilisateurs authentifiÃ©s peuvent lire la prÃ©sence
        // (nÃ©cessaire pour que clients voient agent typing et vice-versa)
        allow get, list: if isSignedIn();

        // CrÃ©ation/mise Ã  jour: chacun peut gÃ©rer sa propre prÃ©sence
        allow create, update: if isSignedIn() && (
          presenceId == 'user_' + uid()
          || presenceId == 'agent_' + uid()
          || isSystem()
        );

        // Suppression: interdit
        allow delete: if false;
      }

      // ========================================
      // SUBCOLLECTION: participants
      // ========================================

      match /participants/{participantId} {

        // Lecture: tous les utilisateurs authentifiÃ©s peuvent lire les participants
        allow get, list: if isSignedIn();

        // CrÃ©ation: staff support seulement
        allow create: if isSupportStaff() || isSystem();

        // Mise Ã  jour et suppression: interdit
        allow update, delete: if false;
      }
    }

    // ========================================
    // COLLECTION: supportInboxState
    // ========================================

    match /supportInboxState/{docId} {
      // Lecture et Ã©criture: staff support seulement
      allow get, list: if isSupportStaff() || isSystem();
      allow create, update: if isSupportStaff() || isSystem();
      allow delete: if false;
    }

    // ========================================
    // COLLECTION: orders
    // ========================================

    match /orders/{orderId} {
      // Lecture: propriÃ©taire de la commande, admin ou support
      allow get: if isSignedIn() && (
        resource.data.userId == uid()
        || isAdminRole()
        || isSupportStaff()
      );

      // Liste: filtrÃ©e par userId cÃ´tÃ© client
      allow list: if isSignedIn() && (
        isAdminRole()
        || isSupportStaff()
        || request.auth.uid != null
      );

      // CrÃ©ation: SEULEMENT depuis le serveur (API routes) pour sÃ©curitÃ©
      // Le client ne peut JAMAIS crÃ©er directement une commande "paid"
      allow create: if (
        // Serveur (API routes via service account)
        isSystem()
        
        // Admin pour testing seulement
        || isAdminRole()
      )
      // Validations communes
      && request.resource.data.orderReference is string
      && request.resource.data.orderReference.size() > 0
      && request.resource.data.paymentMethod in ['card', 'mobile_money', 'cash']
      && request.resource.data.amount is number
      && request.resource.data.amount > 0
      && request.resource.data.currency == 'xaf'
      && request.resource.data.items is list
      && request.resource.data.items.size() > 0
      && request.resource.data.createdAt is timestamp;

      // Mise Ã  jour: propriÃ©taire, webhook Stripe, admin ou support
      // Permet au webhook de mettre Ã  jour le statut
      allow update: if (
        // PropriÃ©taire peut mettre Ã  jour certains champs
        (isSignedIn() && resource.data.userId == uid())
        
        // Admin et support peuvent tout modifier
        || isAdminRole()
        || isSupportStaff()
        
        // Webhook Stripe peut mettre Ã  jour (via service account)
        || isSystem()
      );

      // Suppression: admin seulement
      allow delete: if isAdminRole();
    }

    // ========================================
    // COLLECTION: payments
    // ========================================

    match /payments/{paymentId} {
      // Lecture: admin, support ou systÃ¨me (webhook)
      allow get, list: if isAdminRole() || isSupportStaff() || isSystem();

      // CrÃ©ation: systÃ¨me (API route) ou utilisateur authentifiÃ©
      allow create: if isSignedIn() || isSystem();

      // Mise Ã  jour: systÃ¨me uniquement (webhook Stripe)
      allow update: if isSystem();

      // Suppression: interdit
      allow delete: if false;
    }

    // ========================================
    // COLLECTION: addresses
    // ========================================

    match /addresses/{addressId} {
      // Lecture GET (document spÃ©cifique): utilisateur propriÃ©taire ou admin/support
      allow get: if isSignedIn() && (
        resource.data.userId == uid()
        || isAdminRole()
        || isSupportStaff()
      );

      // Lecture LIST (collection): filtrÃ©e cÃ´tÃ© client/serveur par userId
      // On autorise la lecture pour tous les utilisateurs authentifiÃ©s
      // Les API routes filtrent par userId, donc sÃ©curisÃ©
      allow list: if isSignedIn();

      // CrÃ©ation: utilisateur connectÃ©
      allow create: if isSignedIn()
        && request.resource.data.userId == uid()
        && request.resource.data.label in ['home', 'work', 'other']
        && request.resource.data.quartier is string
        && request.resource.data.quartier.size() > 0
        && request.resource.data.quartier.size() <= 100
        && request.resource.data.avenue is string
        && request.resource.data.avenue.size() > 0
        && request.resource.data.avenue.size() <= 200
        && request.resource.data.pointDeRepere is string
        && request.resource.data.pointDeRepere.size() > 0
        && request.resource.data.pointDeRepere.size() <= 200
        && request.resource.data.isDefault is bool
        && request.resource.data.createdAt is timestamp
        && request.resource.data.updatedAt is timestamp;

      // Mise Ã  jour: propriÃ©taire seulement (ne peut pas changer userId)
      allow update: if isSignedIn()
        && resource.data.userId == uid()
        && request.resource.data.userId == uid();

      // Suppression: propriÃ©taire seulement
      allow delete: if isSignedIn()
        && resource.data.userId == uid();
    }

    // ========================================
    // FALLBACK: deny all by default
    // ========================================

    match /{document=**} {
      allow read, write: if false;
    }
  }
}
